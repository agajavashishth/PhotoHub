// Imports the Google Cloud client library
const {Storage} = require('@google-cloud/storage');
const {fromString} = require('uuidv4');

const storage = new Storage({keyFilename: "<FILE PATH TO GCP Service Account Credentials>"});
const fs = require('fs');
const path = require('path');
const fileList = [];
const cwd = path.join(__dirname, '..');

module.exports = {
    //list all buckets in project
    listBuckets = async function (data){
      // Lists all buckets in the current project
      const [buckets] = await storage.getBuckets();

      buckets.forEach(bucket => {
        data.push(bucket.name);
      });
    },

    //creates a new bucket with bucketName [CHANGE THE LOCATION AND STORAGE CLASS]
    createBucket = async function (bucketName){
        const [bucket] = await storage.createBucket(bucketName, {
        location: 'ASIA',
        storageClass: 'COLDLINE',
        });
        console.log(`Bucket ${bucket.name} created.`);
        createBucket().catch(console.error);
    },

    //use this function to add the uploader as a bucket owner, project owner is in the default owner ACL
    addBucketOwner = async function (bucketName, userEmail){
      await storage.bucket(bucketName).acl.owners.addUser(userEmail);

      console.log(`Added user ${userEmail} as an owner on bucket ${bucketName}.`);
    },

    //prints the Bucket ACL
    printBucketAcl = async function (bucketName, data){
      // Gets the ACL for the bucket
      const [acls] = await storage.bucket(bucketName).acl.get();
      data = JSON.stringify(JSON.parse(acls));
    },

    //deletes a bucket
    deleteBucket = async function (bucketName){
        // Deletes the bucket
        await storage.bucket(bucketName).delete();
        console.log(`Bucket ${bucketName} deleted.`);
        deleteBucket().catch(console.error);
    },

    //lists all files in a bucket, returns fileNames in data object
    listAllFiles = async function (bucketName, data){
        // Lists files in the bucket
      const [files] = await storage.bucket(bucketName).getFiles();

      files.forEach(file => {
        data.push(file.name)
      });
    },

    //upload file, default public read is on
    uploadFile = async function (bucketName, filePath){
      let n = uuid();
      await storage.bucket(bucketName).upload(filePath, {
        //destination file-name generated by UUIDv4;
        destination: n,
        //default setting is public
        public: true,
        // Support for HTTP requests made with `Accept-Encoding: gzip`
        gzip: true,
        // By setting the option `destination`, you can change the name of the
        // object you are uploading to a bucket.
        metadata: {
          // Enable long-lived HTTP caching headers
          // Use only if the contents of the file will never change
          // (If the contents will change, use cacheControl: 'no-cache')
          cacheControl: 'public, max-age=31536000',
        },
      });
      console.log(`${filename} uploaded to ${bucketName}.`);
      uploadFile().catch(console.error);
    },

    //upload an entire directory, each individual file named with uuidv4
    uploadDirectory = async function (bucketName, directoryPath){
      // get the list of files from the specified directory
      let dirCtr = 1;
      let itemCtr = 0;
      const pathDirName = path.dirname(directoryPath);

      getFiles(directoryPath);

      function getFiles(directory) {
        fs.readdir(directory, (err, items) => {
          dirCtr--;
          itemCtr += items.length;
          items.forEach(item => {
            const fullPath = path.join(directory, item);
            fs.stat(fullPath, (err, stat) => {
              itemCtr--;
              if (stat.isFile()) {
                fileList.push(fullPath);
              } else if (stat.isDirectory()) {
                dirCtr++;
                getFiles(fullPath);
              }
              if (dirCtr === 0 && itemCtr === 0) {
                onComplete();
              }
            });
          });
        });
      }

      async function onComplete() {
        const resp = await Promise.all(
          fileList.map(filePath => {
            let destination = uuid();
            return storage
              .bucket(bucketName)
              .upload(filePath, {destination})
              .then(
                uploadResp => ({fileName: destination, status: uploadResp[0]}),
                err => ({fileName: destination, response: err})
              );
          })
        );

        const successfulUploads =
          fileList.length - resp.filter(r => r.status instanceof Error).length;
        console.log(
          `${successfulUploads} files uploaded to ${bucketName} successfully.`
        );
      }

      uploadDirectory().catch(console.error);
    },

    //make file private, remove public read setting
    makeFilePrivate = async function (bucketName, fileName){
      // Makes the file public
      await storage.bucket(bucketName).file(fileName).makePrivate();
      console.log(`gs://${bucketName}/${filename} is now public.`);
      makeFilePrivate().catch(console.error);
    },

    //add file owner
    addFileOwner = async function (bucketName, fileName, userEmail){
      await storage
        .bucket(bucketName)
        .file(filename)
        .acl.owners.addUser(userEmail);

      console.log(`Added user ${userEmail} as an owner on file ${filename}.`);
      addFileOwner().catch(console.error);
    },

    //make file public, remove private setting
    makeFilePublic = async function (bucketName, fileName){
      // Makes the file public
      await storage.bucket(bucketName).file(filename).makePublic();

      console.log(`gs://${bucketName}/${filename} is now public.`);
      makeFilePublic().catch(console.error);
    },

    //print file ACL, returns data in data object
    printFileAcl = async function (bucketName, fileName, data){
      // Gets the ACL for the bucket
      const [acls] = await storage.bucket(bucketName).file(filename).acl.get();
      data = JSON.stringify(JSON.parse(acls));
    },

    //deletes file fileName from bucket BucketName
    deleteFile = async function (bucketName, fileName){
      // Deletes the file from the bucket
      await storage.bucket(bucketName).file(filename).delete();
      console.log(`gs://${bucketName}/${filename} deleted.`);
      deleteFile().catch(console.error);
    },

    //
    getFileMetadata = async function (bucketName, fileName, data){
      // Gets the metadata for the file
      const [metadata] = await storage
        .bucket(bucketName)
        .file(filename)
        .getMetadata();

      data.name = metadata.name.toString();
      data.bucket = metadata.bucket.toString();
      data.medialink = metadata.medialink.toString();
      data.updated = metadata.updated.toString();
      data.metadata = JSON.stringify(JSON.parse(metadata.metadata));

      console.log('File: ${metadata.name}');
      console.log('File: ${metadata.mediaLink`}');
      getMetadata().catch(console.error);
    },

    //
    setFileMetadata = async function (bucketName, fileName, data){
      // Set file metadata.
      var d = new Date();
      const date = d.toString();
      const [metadata] = await storage
        .bucket(bucketName)
        .file(filename)
        .setMetadata({
          // Predefinded metadata for server e.g. 'cacheControl', 'contentDisposition',
          // 'contentEncoding', 'contentEncoding', 'contentLanguage', 'contentType'
          contentDisposition: 'attachment; filename*=utf-8\'\'"anotherImage.jpg"',
          contentType: 'image/jpeg',

          // Note or actionable items for user e.g. uniqueId,
          // object description or other useful information.
          metadata: {
            description: data.descripton,
            modified: Date.now(),
          },
        });

      console.log(metadata);
      setFileMetadata().catch(console.error);
    },

    //
    getSignedUrl = async function (bucketName, filename, link){
      // These options will allow temporary read access to the file
      const options = {
        version: 'v2', // defaults to 'v2' if missing.
        action: 'read',
        expires: Date.now() + 1000 * 60 * 60, // one hour
      };

      // Get a v2 signed URL for the file
      const [url] = await storage
        .bucket(bucketName)
        .file(filename)
        .getSignedUrl(options);

      link = url.toString();
      console.log(`The signed url for ${filename} is ${url}.`);
      getSignedUrl().catch(console.error);
    },

};
